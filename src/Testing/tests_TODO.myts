//TODO EN GENERAL: que las pruebas impriman un mensaje facil de leer
//cuando pasan y cuando no

{
    console = null;//Deberia de tronarse la consola :s
    console.log("a");//no deberia de funcionar
}

//algo que testee que sea posible sobreescribir el console
{
    let console:number = 10;
    console.log("Javier");//Deberia de dar error
}

// I DONT EVEN KNOW WHAT THE FUCK HAPPENS HERE BUT IT SHOULD BE TESTED
// it might even be a problem
{
    type A = {
        a:number,
        b:number
    }

    function setParam(a:number){
        a = 10;
    }

    let myA = { a:10, b:undefined }

    console.log(myA.b);//no longer prints undefined
    console.log(myA.c);//prints undefinded??????

    setParam(myA.b);
    setParam(myA.c);

    // we could set the params like this too???
    // myA.b = 10;
    // myA.c = 10;

    console.log(myA.b);//no longer prints undefined
    console.log(myA.c);//prints undefinded??????
}

//algo que testee que sea posible sobreescribir el console
{
    let console:number = 10;
    console.log("Javier");//Deberia de dar error
}

//Algo que verifique si se tira error cuando se llama una funcion
//con un custom type o con array

//Verificar que NO exista conflicto entre dos custom types cuando sea
//adecuado
{
    type A = {
        a:number,
        b:number
    }
    function aFunc(a:A){
        
    }
    {
        //No importa si el nombre de B es A. Esto corre de cualquier manera
        type B = {
            a:number,
            b:number
        }

        let a:B = {a:10, b:10};
        aFunc(a);
    }
}

{
    type A = {
        a:number,
        b:number
    }
    {
        type A = {
            a:string,
            b:string
        }

        //Esta function debe de tener la segunda def de A
        function afunc(a:A){
            
        }
    }
}


// TODO algo que verifique que la verificacion de tipos no 
// solo revise si dos tipos son CUSTOM
 

// TODO: algo que pruebe que los primitivos si se pasen por valor

// TODO: algo que pruebe que los Array y los custom se pase por referencia
 
 
//Pruebas de + con string
{
    //Number
    console.log("*******************Number*******************");
    let num = 10;
    let a = num + "s";
    console.log(a);
    let b = "s" + num;
    console.log(b);

    //String
    console.log("*******************String*******************");
    let s = "10";
    let c = s + "s";
    console.log(c);
    let d = "s" + num;
    console.log(d);

    //Boolean
    console.log("*******************Boolean*******************");
    let bool = true;
    let e = bool + "s";
    console.log(e);
    let f = "s" + bool;
    console.log(f);

    //null
    console.log("********************null********************");
    let _null = null;
    let g = _null + "s";
    console.log(g);
    let h = "s" + _null;
    console.log(h);   

    //undefined
    console.log("******************undefined******************");
    let _undefined = undefined;;
    let i = _undefined + "s";
    console.log(i);
    let j = "s" + _undefined
    console.log(j);   

    //console
    console.log("*******************console*******************");
    let _my_console = console;;
    let k = _my_console + "s";
    console.log(k);
    let l = "s" + _my_console;
    console.log(l);

    //Array
    console.log("*******************Array********************");
    let myArray:Array<string> = ["10", "10"];
    let m = myArray + "s";//string
    console.log(m);
    let n = "s" + myArray;//string
    console.log(n);

    //Custom
    console.log("*******************Custom*******************");
    type A = {
        a:number,
        b:number
    }
    let myType:A = { a: 10, b: 10 };
    let o = "s" + myType;//string
    console.log(o);
    let p = myType + "s";//string
    console.log(p);

    //EmptyArray
    console.log("****************EmptyArray*****************");
    let myEmptyArray:Array<string> = [];
    let q = myEmptyArray + "s";//string
    console.log(q);
    let r = "s" + myEmptyArray;//string
    console.log(r);
}

//Probar que los los MyType se pasen por referencia
//sin importar si vinieron de un member access
{

    type A = {
        a:number,
        b:number
    }
    type B = {
        a:number,
        b:A
    }
    let myType:A = { a: 10, b: 10 };
    let o = "s" + myType;//string
    console.log(o);
    let p = myType + "s";//string
    console.log(p);
}
//TODO: hacer la prueba anterior para arreglos tambien

//TODO: Probar que las definiciones de tipos puedan venir en 
//desorden y que puedan ser circulares


//TODO: Probar que las dos expresiones en un operacion de potencia (**)
//se calculen de derecha a izquierda (no solo es que se parceen de derecha
//a izquierda, tambien  se tienen que calcular de derecha a izquierda)

//TODO: Poner expresiones aritmeticas super largas (ver pruebas de compi 1)

//TODO: Poner expresiones en las que - unario y - binario pueden dar problema


//Probar que poner en null otra variable con el mismo objeto no afecte a la
//variable original
{
    type A = {
        a:string,
        b:number
    }

    let a:A = { a:"Javier", b:1 };
    let b = a;
    b = null;
    console.log(a);//No deberia de imprimir null
}

//IMPORTANTE: que la comparacion con el literal null y una variable que fue
//asignada a null si funcione bien!
{
    type A = {
        a:string,
        b:number
    }

    let a:A = { a:"Javier", b:1 };
    a = null;
    if(a == null){
        console.log(true);
    }
    console.log(a);//No deberia de imprimir null
}

//Que pase los member access por referencia tambien
{
    //TODO: ponerle mejores nombres
    type A = {
        a:B,
        b:number
    }
    type B = {
        a:string
    }
    
    function nullify(b:B){
        b = null;
    }

    let b:B = {
        a:"Javier"
    }
    let a:A = {
        a:b,
        b:10
    }

    nullify(a.a);
    console.log(a.a);//Deberia de imprimir null
}

//TODO: 'formalizar' esta prueba
{
    //this, somehow prints: [ null, null, null, null, null, null, null, null, null, null ]
    let anArray:number[] = [];
    anArray.length = 10;
    console.log(anArray);
}
  
{
    [10] = [1,2,3,4];//deberia ser un error
    [10, 10].length = 10;//No deberia ser error

}

{
    let anArray:number[]
    console.log(anArray = [10, 2, 3]);//esto imprime el arreglo
}

{
    console.log(let anArray:number[] = [10, 2, 3]);//Pero las declaraciones no pueden ser expresion
}

//TODO: algo que revice si el operator precedence de '=' al hacer assignment es correcto

{
    type A = {
        a:string,
        b:string
    }
    type B = {
        a:string,
        b:string
    }

    function test(a:A){
        console.log(a);
    }

    let b:B = {a:"Javier", b:"Antonio"};
    test(b);//Esto NO debe dar error de tipos
}

{
    type A = {
        a:string,
        b:string
    }

    function test1(a:A){
        console.log(a);
    }

    test({a:"Javier", b:"Javier"});//Esto NO debe dar error de tipos
}

{
    type A = {
        a:string,
        b:string
    }

    let a = ({a:"Javier", b:"Javier"});//Should work
}
{
    type A = {
        a:number,
        b:B
    }
    type B = {
        a:A,
        b:number
    }
}

{
    function A(){
        B();
    }
    function B(){
        A();
    }
}

// Truthiness porque typescript es una mierda:
{
    if(true){
        console.log("PASS");
    }
    else{
        console.log("FAIL");
    }
    if(!(false)){
        console.log("PASS");
    }
    else{
        console.log("FAIL");
    }

    if(10){//Any non 0 number
        console.log("PASS");
    }
    else{
        console.log("FAIL");
    }
    if(!(0)){
        console.log("PASS");
    }
    else{
        console.log("FAIL");
    }

    if(!('')){
        console.log("PASS");
    }
    else{
        console.log("FAIL");
    }
    if('false'){//i.e. any other string
        console.log("PASS");
    }
    else{
        console.log("FAIL");
    }

    if(!(null)){//null is never true
        console.log("PASS");
    }
    else{
        console.log("FAIL");
    }

    if(!(undefined)){//undefined is never true
        console.log("PASS");
    }
    else{
        console.log("FAIL");
    }

    if([]){//any array empty or not is never false
        console.log("PASS");
    }
    else{
        console.log("FAIL");
    }

    if({}){//any object empty or not is never false
        console.log("PASS");
    }
    else{
        console.log("FAIL");
    }
}

// About truthiness
// copied from: https://medium.com/coding-in-simple-english/what-are-truthy-values-in-javascript-e037bdfa76f8
// might be useful in one way or another
{
    const empty = {}
    empty ? "truthy" : "falsy"; // truthy

    [] ? "truthy" : "falsy"; // truthy

    0 ? "truthy" : "falsy"; // falsy
    37 ? "truthy" : "falsy"; // truthy

    false ? "truthy" : "falsy"; // falsy
    true ? "truthy" : "falsy"; // truthy

    0n ? "truthy" : "falsy"; // falsy
    37n ? "truthy" : "falsy"; // truthy

    "" ? "truthy" : "falsy"; // falsy
    "any string" ? "truthy" : "falsy"; // truthy

    null ? "truthy" : "falsy"; // falsy
    undefined ? "truthy" : "falsy"; // falsy
}

//TODO: Algo para probar truthiness con operadores
//TODO: Revisar bien que cosas son las que causan truthiness


//TODO: Una declarion que verifique que si se haga bien la compativilidad de tipos entre
//Customs

//TODO: Una declarion que verifique que si se haga bien la compativilidad de tipos entre
//Arrays

//Probar que no el simbolo como tal sea capas de mantener su tipo
{
    type A = {
        a: string;
        b: string;
    }
    type B = {
        a: number;
        b: number;
    }

    let a:A;
    console.log(a);//deberia de imprimir undefined
    let b:B = { a: 10, b: 10 }
    a = b;//Esto no deberia dar error
}

//TODO: [?] los types pueden tener inicializaciones default????????????????????

//Probar que se puedan tener variables y types con el mismo nombre
{
    type A = {
        a: string;
        b: string;
    }

    //This is ok acording to typescript
    let A:A = {a:"", b:""};
}

//TODO: Algo para probar el const


{//no se cual es la respuesta aqui. Depende de lo que digan en el github
    type A = {
        a: string;
        b: string;
    }

    //Esto NO se puede en TypeScript
    let a:A = undefined;

    //Ni esto tampoco
    let b:A = null;

    //Si si se puede en nuestro lenguaje entonces se puede hacer tambien con primitivos
    let c:number = undefined;
    let d:number = null;
    
    let e:string = undefined;
    let f:string = null;
    
    let g:boolean = undefined;
    let h:boolean = null;
}

//TODO: pruebas super anidadas con el member access
//que hagan el acceso y tambien la asignacion

{
    function other_nullify(a:number){
        a = null;
    }

    let array = [10, 10];
    other_nullify(array[0]);
    console.log(array);//Should NOT print null because a[0] is a primitive
}

//TODO: algo que verifique que la asignacion retorne un valor


//No se ni siquiera si esto sirve en typescript. Per
{
    type A = {
        a: string = "Default A";
        b: string = "Dafault A";
    }

    {//
        type A = {
            a: A;//Este A hace referencia al A en este scope
        }
        
        let a:A;
        console.log(a);
    }
}

{
    let a = 10;
    (a = 10) = 20;
}

{
    "a" = "a";
    console.log(a);
}

{
    type string = {//we should print a special error message
        a:number;
    }
}

{
    type A = {
        a: string;
        b: B;
    }
    type B = {
        a: A;
        b: number;
    }

    let a:A = {
        a:"a1", 
        b : { 
            a: {
                a:"a1", 
                b : { 
                    a: {
                        a:"a2", 
                        b: null
                    },
                    b: 30
                }
            },
            b: 20
        }
    };

    console.log(a);

}

//Que no muera todo si no existe el tipo
{
    type A = {
        a: string;
        b: B;
    }
}

//Que los break error get propagated thru function calls
{
    function a_bad_break():void{
        break;
    }

    while(true){
        console.log("Solo esto se deberia de imprimir");
        a_bad_break();
        console.log("Si esto se imprime algo anda mal");
        break;
    }
}

//NO SE COMO NI PORQUE PASO ESTA PRUEBA
{
    let a:number = 10;
    let b:number = a;

    b = 20;

    console.log(a);//print 10
    console.log(b);//print 20
}

//TODO: Test assignment and declaration with undefined

//TODO: algo que pruebe si no se acepta diferente numero de args a params
//      algo que pruebe si se revisa que los tipos de args sean igual a los de params


//TODO: a good unit test candidate would be compareTypes and those types of functions.
//      it would have to be very thorough to be of any use. And to making it thorough
//      would take time


{
    let a:number = 10;
    let b:number = a;

    b = 20;

    console.log(a);//ambos deberia de imprimir { a: 20 }
    console.log(b);
}


//TODO: prueba que typedef dentro de scope den error 

//BUG!!
{
    type A = {
        a: number,
    }
    let a:A = {a:10};
    let b:A = a;

    a.a = 20;
	a = null;

    console.log(a);//IMPRIME UNDEFINED CUANDO DEBERIA DE IMPRIMIR null
    console.log(b);
}

{
    function hello(a:number):void{
        console.log("Hello " + a);//should print "Hello 10"
        a = null;
    }

    let a = 10;
    hello(a);
    console.log(a);//should print 10
}

{
    type A = {
        a: number,
    }
    function nullifyA(a:A){

    }
    //this function shouldn't have any effects on the argument that
    //was passed to it
    function nullifyNumber(a:number){
        a = null;
    }

    a.a = 20;
	a = null;

    console.log(a);//IMPRIME UNDEFINED CUANDO DEBERIA DE IMPRIMIR null
    console.log(b);
}

//old bug:
//failing test for null bug
{
    console.log(null);//BUG prints undef
    console.log(undefined);
    let a = null;
    let b = undefined;
    console.log(a);//BUG prints undef
    console.log(b);
}

//TODO: algo que pruebe si corremos los typedefs antes de las funciones

{
    let n:number = 0;

    while(n < 10){
    n = n + 1;
    console.log(n);
    continue;
    console.log("FAIL");
    }
}

//TODO: test return jumpers, empty, not empty, correct, with incorrect type, with incorrect void/not_void

//TODO: mas de estas:
//Para verificar que regresemos al scope global antes de llamar a las funciones
{
    let b = "PASS";
    function lol():void{
        console.log(a);
        console.log(b);
    }

    {
        let a = "FAIL";
        lol();
    }
}

//TODO: finish this test
//Possible bug we caught
{
    //we didnt check for type correctness in assignment
}

{
    let a:Array<number>[];  
    let b:Array<number[]>;
}

{
    type A = {
        a:C[]
    }
    type B = {
        b:Array<Array<Array<Array<C>>>>;
    }
    type C = {
        c:number;
    }
}

{
    let a:Array<Array<Array<Array<C>>>>;//we should get an error here!
    let b:Array<C>;//we should get an error here!
    let c:C[];//we should get an error here!
    let d:C[][][][];//we should get an error here!
}

//TODO tests for ternary!

{
    console.log([1,2,3,4]);
    console.log([1,2,3,"4"]);//Esto deberia dar error
}

{
    console.log([1,2,3,4]);
    console.log([1,2,3,"4"]);//Esto deberia dar error
}

//TODO: more tests for typechecking arrays
{
    let a:number[] = [1,2,3,"4"];//Esto deberia dar error
}

//TODO: probar que con push se pasen las mierdas por referencia tambien. como cualquier otra funcion

//TODO: push return the length of the array


//TODO: Test block. The grammar was full of bugs!


//This error would be impossible to catch unless we do some MAYOR changes to the everything
{
    let a = 10;
    {
        let a = a;
    }
}

//TODO: tests para for que se apeguen bien bien a https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Sentencias/for

//BIG TODO: Something that tests if we handle the double scope properly AND if we dont fuck up the scope stack if an error occurs on the initial expression
//          see your runFor code


//TODO: something that test if the finalExpression runs outside of the scope of for's block

//this is one of the biggest bugs. second only to the 'symbols dont carry their type bug!'
//BUG: I think... this should be an error but its not
{
    let i = 0;
    for(let i = i; i < 10; i++){//Variable i used before its declaration
        
    }
}
{
    let a = [1,2,3,4];
    for(let a of a){//this is an error
        a = 0;
    }
}


//TODO: very rigorous testing with jumpers. pls

//BUG: this should be an error in TS. But i dont think it is in C. idk
{
    let a =10;
    {
        console.log(a);
        let a = 10;
    }
}

{
    {//(solo funciona en myTs)
        let array = [0,1,2,3,4];
        for(let item of array){
            array = null;
            console.log(item);
        }
        //0 1 2 3 4
    }

    console.log("--------------------");

    {
        let array = [0,1,2,3,4];
        for(let item of array){
            array = [];
            console.log(item);
        }
        //0 1 2 3 4
    }

    console.log("--------------------");

    {
        let array = [0,1,2,3,4];
        for(let item of array){
            console.log(item);
            if(array.length < 10){
                array.push(-1);
            }
        }
        //0 1 2 3 4 -1 -1 -1 -1 -1
    }

    console.log("--------------------");

    {
        let array = [0,1,2,3,4];
        let arrayCopy = array;
        for(let item of array){
            console.log(item);
            arrayCopy.pop();
        }
        //0 1 2
    }
}